#!/usr/bin/env python3
"""
Evaluate stem quality (reference-free) and join with runtime.

Input:
  - runs.csv (generated by your separation script)
Output:
  - comparison.csv (one row per {input_file, model_filename} pair)

Metrics (higher total score is better):
  - IVBE_instrumental_300_3400: energy of instrumental in voice band (lower is better)
  - VPR_vocals_percussive_ratio: percussive ratio in vocals via HPSS (lower is better)
  - VBR_vocals_band_ratio: ratio of vocals energy in 300â€“3400 Hz over total (higher is better)
  - score_0to1: weighted combination
  - quality_per_second: score / proc_seconds
"""

from __future__ import annotations
import csv
import math
from pathlib import Path
from typing import Dict, Tuple

import numpy as np
import soundfile as sf
import librosa

RUNS_CSV = Path("./runs.csv").resolve()
OUT_CSV  = Path("./comparison.csv").resolve()

def rms_normalize(y: np.ndarray) -> np.ndarray:
    rms = float(np.sqrt(np.mean(y**2) + 1e-12))
    return y / max(rms, 1e-6)

def load_mono(path: Path, sr: int = 44100) -> Tuple[np.ndarray, int]:
    y, srr = sf.read(str(path), always_2d=False)
    if y.ndim == 2:
        y = y.mean(axis=1)
    if srr != sr:
        y = librosa.resample(y.astype(np.float32), orig_sr=srr, target_sr=sr)
        srr = sr
    y = rms_normalize(y.astype(np.float32))
    return y, srr

def band_energy(y: np.ndarray, sr: int, fmin: float, fmax: float) -> float:
    S = np.abs(librosa.stft(y, n_fft=2048, hop_length=512)) ** 2
    freqs = librosa.fft_frequencies(sr=sr, n_fft=2048)
    band = (freqs >= fmin) & (freqs <= fmax)
    return float(S[band].sum())

def percussive_ratio(y: np.ndarray, sr: int) -> float:
    S = librosa.feature.melspectrogram(y=y, sr=sr, n_fft=2048, hop_length=512, n_mels=128)
    H, P = librosa.decompose.hpss(S)
    eH, eP = float(H.sum()), float(P.sum())
    return eP / max(eH + eP, 1e-12)

def band_ratio(y: np.ndarray, sr: int, fmin: float, fmax: float) -> float:
    S = np.abs(librosa.stft(y, n_fft=2048, hop_length=512)) ** 2
    freqs = librosa.fft_frequencies(sr=sr, n_fft=2048)
    band = (freqs >= fmin) & (freqs <= fmax)
    e_band = float(S[band].sum())
    e_tot  = float(S.sum())
    return e_band / max(e_tot, 1e-12)

def score_pair(vocals_path: Path, instrumental_path: Path, proc_seconds: float) -> Dict[str, float]:
    sr = 44100
    v, _ = load_mono(vocals_path, sr=sr)
    i, _ = load_mono(instrumental_path, sr=sr)

    ivbe = band_energy(i, sr, 300, 3400)            # lower is better
    vpr  = percussive_ratio(v, sr)                  # lower is better
    vbr  = band_ratio(v, sr, 300, 3400)             # higher is better

    # monotonic transforms to [0,1]-ish scores
    ivbe_score = 1.0 / (1.0 + ivbe)
    vpr_score  = 1.0 / (1.0 + 10.0 * vpr)
    vbr_score  = vbr

    total = (0.45 * ivbe_score) + (0.35 * vbr_score) + (0.20 * vpr_score)

    out = {
        "IVBE_instrumental_300_3400": ivbe,
        "VPR_vocals_percussive_ratio": vpr,
        "VBR_vocals_band_ratio": vbr,
        "score_0to1": total,
    }
    if proc_seconds > 0:
        out["quality_per_second"] = total / proc_seconds
    else:
        out["quality_per_second"] = math.nan
    return out

def main() -> None:
    if not RUNS_CSV.exists():
        raise SystemExit(f"runs.csv not found at {RUNS_CSV}")

    # group rows by (input_file, model_filename)
    groups: Dict[Tuple[str, str], Dict[str, dict]] = {}
    with RUNS_CSV.open("r", newline="") as f:
        reader = csv.DictReader(f)
        for row in reader:
            key = (row["input_file"], row["model_filename"])
            name = row["output_name"].lower()
            if key not in groups:
                groups[key] = {"rows": []}
            groups[key]["rows"].append(row)

    results = []
    for (input_file, model_filename), bucket in groups.items():
        rows = bucket["rows"]
        # find vocals and instrumental paths
        vocals_row = next((r for r in rows if "vocals" in r["output_name"].lower()), None)
        instr_row  = next((r for r in rows if "instrumental" in r["output_name"].lower()), None)
        if not vocals_row or not instr_row:
            # incomplete pair; skip
            continue

        vocals_path = Path(vocals_row["output_path"])
        instr_path  = Path(instr_row["output_path"])
        if not vocals_path.exists() or not instr_path.exists():
            continue

        # use the same proc_seconds for the pair (any row works)
        try:
            proc_seconds = float(vocals_row.get("proc_seconds", "0") or "0")
        except ValueError:
            proc_seconds = 0.0

        metrics = score_pair(vocals_path, instr_path, proc_seconds)

        results.append({
            "input_file": input_file,
            "model_filename": model_filename,
            "vocals_path": str(vocals_path),
            "instrumental_path": str(instr_path),
            "proc_seconds": f"{proc_seconds:.3f}",
            **{k: (f"{v:.6f}" if isinstance(v, float) else v) for k, v in metrics.items()},
        })

    if not results:
        raise SystemExit("No complete (Vocals, Instrumental) pairs found to evaluate.")

    # write comparison.csv
    OUT_CSV.parent.mkdir(parents=True, exist_ok=True)
    fieldnames = [
        "input_file", "model_filename",
        "vocals_path", "instrumental_path",
        "proc_seconds",
        "IVBE_instrumental_300_3400",
        "VPR_vocals_percussive_ratio",
        "VBR_vocals_band_ratio",
        "score_0to1",
        "quality_per_second",
    ]
    with OUT_CSV.open("w", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        for r in results:
            writer.writerow(r)

    print(f"Written: {OUT_CSV} ({len(results)} rows)")

if __name__ == "__main__":
    main()
